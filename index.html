<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STACKED! Card Game</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        const StackedGame = () => {
            const getCardScore = (rank) => {
                if (rank === 'A') return 15;
                if (['K', 'Q', 'J', '10'].includes(rank)) return 10;
                return 5;
            };

            const createDeck = () => {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
                const deck = suits.flatMap(suit => 
                    ranks.map(rank => ({ 
                        id: `${rank}${suit}`, 
                        rank, 
                        suit, 
                        score: getCardScore(rank),
                        numValue: rank === 'A' ? 1 : isNaN(parseInt(rank)) ? 0 : parseInt(rank)
                    }))
                );
                
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
                return deck;
            };

            // Game State
            const [players, setPlayers] = useState([]);
            const [boardCards, setBoardCards] = useState([]);
            const [deck, setDeck] = useState([]);
            const [currentPlayer, setCurrentPlayer] = useState(0);
            const [selectedHandCard, setSelectedHandCard] = useState(null);
            const [selectedBoardCards, setSelectedBoardCards] = useState([]);
            const [message, setMessage] = useState('');
            const [gameStarted, setGameStarted] = useState(false);
            const [isAIThinking, setIsAIThinking] = useState(false);
            const [lastCapturer, setLastCapturer] = useState(null);
            const [lastAction, setLastAction] = useState(null);
            const [gameState, setGameState] = useState('PLAYING'); // PLAYING, DEAL_NEW_HAND, END_ROUND, END_GAME

            const startGame = () => {
                console.log('üéÆ Starting new game');
                
                const newDeck = createDeck();
                
                // Deal initial hands and board
                const newPlayers = Array.from({ length: 3 }, (_, i) => ({
                    id: i,
                    name: i === 0 ? 'You' : `AI ${i}`,
                    hand: newDeck.slice(i * 4, (i + 1) * 4),
                    captured: [],
                    score: 0
                }));
                
                const initialBoard = newDeck.slice(12, 16);
                const remainingDeck = newDeck.slice(16);
                
                console.log('üìä Initial state:');
                console.log('Players:', newPlayers);
                console.log('Board:', initialBoard);
                console.log('Deck remaining:', remainingDeck.length);
                
                setPlayers(newPlayers);
                setBoardCards(initialBoard);
                setDeck(remainingDeck);
                setCurrentPlayer(0);
                setGameStarted(true);
                setSelectedHandCard(null);
                setSelectedBoardCards([]);
                setMessage('Your turn! Select a card from your hand.');
                setIsAIThinking(false);
                setLastCapturer(null);
                setLastAction(null);
                setGameState('PLAYING');
            };

            const canCapture = (handCard, boardCards) => {
                if (boardCards.length === 0) return false;
                
                // Rank matching capture
                if (boardCards.every(card => card.rank === handCard.rank)) return true;
                
                // Number sum capture (only for numbered cards)
                if (handCard.numValue > 0) {
                    const boardSum = boardCards.reduce((sum, card) => sum + (card.numValue || 0), 0);
                    return boardSum === handCard.numValue && boardCards.every(card => card.numValue > 0);
                }
                
                return false;
            };

            const findCaptures = (handCard, boardCards) => {
                const captures = [];
                
                for (let i = 1; i < (1 << boardCards.length); i++) {
                    const combination = [];
                    for (let j = 0; j < boardCards.length; j++) {
                        if (i & (1 << j)) {
                            combination.push(boardCards[j]);
                        }
                    }
                    
                    if (canCapture(handCard, combination)) {
                        captures.push(combination);
                    }
                }
                
                return captures;
            };

            const determineGameState = () => {
                console.log('üîç Determining game state...');
                
                // Check if all hands are empty
                const totalCardsInHands = players.reduce((sum, player) => sum + player.hand.length, 0);
                console.log('Total cards in hands:', totalCardsInHands);
                console.log('Cards in deck:', deck.length);
                
                if (totalCardsInHands === 0) {
                    if (deck.length >= 12) {
                        console.log('üÉè All hands empty, dealing new hand');
                        return 'DEAL_NEW_HAND';
                    } else {
                        console.log('üèÅ Round over - deck empty');
                        return 'END_ROUND';
                    }
                }
                
                // Check win condition
                const winner = players.find(player => player.score >= 500);
                if (winner) {
                    console.log('üèÜ Game over - winner found');
                    return 'END_GAME';
                }
                
                return 'PLAYING';
            };

            const dealNewHand = () => {
                console.log('üÉè Dealing new hand');
                
                if (deck.length < 12) {
                    console.log('‚ö†Ô∏è Not enough cards for new hand');
                    return;
                }
                
                const newPlayers = [...players];
                let deckIndex = 0;
                
                // Deal 4 cards to each player
                for (let i = 0; i < 3; i++) {
                    newPlayers[i].hand = deck.slice(deckIndex, deckIndex + 4);
                    deckIndex += 4;
                }
                
                const newDeck = deck.slice(12);
                
                console.log('New hands dealt, deck now has:', newDeck.length, 'cards');
                
                setPlayers(newPlayers);
                setDeck(newDeck);
                setGameState('PLAYING');
                setMessage(`New hand dealt! ${newDeck.length} cards remaining in deck.`);
                
                // Continue with current player or find next player with cards
                if (currentPlayer > 0 && !isAIThinking) {
                    setTimeout(() => playAITurn(), 1000);
                }
            };

            const endRound = () => {
                console.log('üèÅ Ending round');
                
                // Apply jackpot if there are board cards and someone made a capture
                if (boardCards.length > 0 && lastCapturer !== null) {
                    const newPlayers = [...players];
                    const jackpotScore = boardCards.reduce((sum, card) => sum + card.score, 0);
                    newPlayers[lastCapturer].captured.push(...boardCards);
                    newPlayers[lastCapturer].score += jackpotScore;
                    
                    setPlayers(newPlayers);
                    setBoardCards([]);
                    setMessage(`${newPlayers[lastCapturer].name} wins the jackpot! +${jackpotScore} points from ${boardCards.length} cards!`);
                    
                    console.log('üí∞ Jackpot awarded to player', lastCapturer, 'for', jackpotScore, 'points');
                } else {
                    setMessage('Round ended. No jackpot this time.');
                }
                
                // Check for game winner
                const winner = players.find(player => player.score >= 500);
                if (winner) {
                    setGameState('END_GAME');
                    setMessage(`${winner.name} wins the game with ${winner.score} points!`);
                } else {
                    // Could add new round setup here
                    setMessage('Round complete! Start a new game to continue.');
                }
            };

            const findNextPlayer = () => {
    // Find next player with cards, starting from currentPlayer + 1
    for (let i = 1; i <= 3; i++) {
        const nextPlayerIndex = (currentPlayer + i) % 3;
        if (players[nextPlayerIndex]?.hand.length > 0) {
            return nextPlayerIndex;
        }
    }
    return null; // No player has cards
};

            const executeAction = (action) => {
                console.log('üé¨ Executing action:', action);
// ADD THIS LINE:
if (action.type === 'capture') {
    console.log('üîç CAPTURE DEBUG:', {
        handCard: `${action.handCard.rank}${action.handCard.suit}`,
        boardCards: action.boardCards.map(c => `${c.rank}${c.suit}`),
        isValid: canCapture(action.handCard, action.boardCards)
    });
}
                
                const newPlayers = [...players];
                const player = newPlayers[currentPlayer];
                
                // Remove hand card
                player.hand = player.hand.filter(c => c.id !== action.handCard.id);
                
                if (action.type === 'capture') {
                    // Capture cards
                    const capturedCards = [action.handCard, ...action.boardCards];
                    player.captured.push(...capturedCards);
                    player.score += capturedCards.reduce((sum, card) => sum + card.score, 0);
                    
                    // Remove captured cards from board
                    setBoardCards(boardCards.filter(card => 
                        !action.boardCards.some(captured => captured.id === card.id)
                    ));
                    
                    setLastCapturer(currentPlayer);
                    setLastAction('capture');
                    
                    setMessage(`${player.name} captured ${capturedCards.length} cards for ${action.score} points!`);
                    console.log('üéâ Capture successful!');
                    
                    // Capture continues turn if player has cards left
                    if (player.hand.length > 0) {
                        setMessage(`${player.name} captured cards and continues their turn!`);
                        setPlayers(newPlayers);
                        return; // Continue same player's turn
                    }
                } else {
                    // Place card
                    setBoardCards([...boardCards, action.handCard]);
                    setLastAction('place');
                    setMessage(`${player.name} placed ${action.handCard.rank}${action.handCard.suit} on the board.`);
                    console.log('üö∂ Place successful!');
                }
                
                setPlayers(newPlayers);
                
                // Check game state after action
                setTimeout(() => {
                    const newGameState = determineGameState();
                    console.log('Next game state:', newGameState);
                    
                    if (newGameState === 'DEAL_NEW_HAND') {
                        dealNewHand();
                    } else if (newGameState === 'END_ROUND') {
                        endRound();
                    } else {
                        // Continue to next player
                        const nextPlayer = findNextPlayer();
                        if (nextPlayer !== null) {
                            setCurrentPlayer(nextPlayer);
                            if (nextPlayer === 0) {
                                setMessage('Your turn! Select a card from your hand.');
                            } else {
                                setTimeout(() => playAITurn(), 1000);
                            }
                        }
                    }
                }, 1500);
            };

            const playAITurn = () => {
                console.log('ü§ñ AI turn for player', currentPlayer);
                
                if (currentPlayer === 0 || !players[currentPlayer] || isAIThinking) return;
                
                setIsAIThinking(true);
                setMessage(`${players[currentPlayer].name} is thinking...`);
                
                setTimeout(() => {
                    const aiPlayer = players[currentPlayer];
                    
                    if (!aiPlayer || aiPlayer.hand.length === 0) {
    console.log('ü™ë AI has no cards - should be sitting out');
    setIsAIThinking(false);
    
    // Trigger game state check instead of returning
    setTimeout(() => {
        const newGameState = determineGameState();
        if (newGameState === 'DEAL_NEW_HAND') {
            dealNewHand();
        } else if (newGameState === 'END_ROUND') {
            endRound();
        } else {
            // Find next player with cards
            const nextPlayer = findNextPlayer();
            if (nextPlayer !== null) {
                setCurrentPlayer(nextPlayer);
            }
        }
    }, 500);
    return;
}

                    let bestMove = null;
                    let bestScore = -1;

                    // Evaluate all possible captures
                    for (const handCard of aiPlayer.hand) {
                        const captures = findCaptures(handCard, boardCards);
                        
                        for (const capture of captures) {
                            const totalScore = [handCard, ...capture].reduce((sum, card) => sum + card.score, 0);
                            if (totalScore > bestScore) {
                                bestScore = totalScore;
                                bestMove = { type: 'capture', handCard, boardCards: capture, score: totalScore };
                            }
                        }
                    }

                    // If no capture found, place lowest scoring card
                    if (!bestMove) {
                        const lowestCard = aiPlayer.hand.reduce((lowest, card) => 
                            card.score < lowest.score ? card : lowest
                        );
                        bestMove = { type: 'place', handCard: lowestCard };
                    }

                    console.log('üéØ AI chose:', bestMove);
                    setIsAIThinking(false);
                    executeAction(bestMove);
                }, 1000);
            };

            // Trigger AI turns
            useEffect(() => {
    if (gameStarted && gameState === 'PLAYING' && currentPlayer > 0 && !isAIThinking && players.length > 0) {
        const currentPlayerData = players[currentPlayer];
        
        // Only trigger AI turn if current player has cards
        if (currentPlayerData && currentPlayerData.hand.length > 0) {
            playAITurn();
        } else {
            console.log(`ü™ë Player ${currentPlayer} sitting out - no cards`);
            
            // Find next player with cards or trigger new hand deal
            const nextPlayerWithCards = findNextPlayer();
            if (nextPlayerWithCards !== null) {
                console.log(`‚û°Ô∏è Advancing to player ${nextPlayerWithCards}`);
                setCurrentPlayer(nextPlayerWithCards);
            } else {
                console.log(`üÉè All players out of cards - checking for new hand`);
                const newGameState = determineGameState();
                if (newGameState === 'DEAL_NEW_HAND') {
                    dealNewHand();
                } else if (newGameState === 'END_ROUND') {
                    endRound();
                }
            }
        }
    }
}, [currentPlayer, gameStarted, gameState, players, isAIThinking]);

            const selectHandCard = (card) => {
                if (currentPlayer !== 0 || isAIThinking || gameState !== 'PLAYING') return;
                setSelectedHandCard(selectedHandCard?.id === card.id ? null : card);
                setSelectedBoardCards([]);
            };

            const selectBoardCard = (card) => {
                if (!selectedHandCard || currentPlayer !== 0 || isAIThinking || gameState !== 'PLAYING') return;
                const isSelected = selectedBoardCards.some(c => c.id === card.id);
                if (isSelected) {
                    setSelectedBoardCards(selectedBoardCards.filter(c => c.id !== card.id));
                } else {
                    setSelectedBoardCards([...selectedBoardCards, card]);
                }
            };

            const captureCards = () => {
                if (!selectedHandCard || selectedBoardCards.length === 0 || isAIThinking) return;
                if (!canCapture(selectedHandCard, selectedBoardCards)) {
                    setMessage('Invalid capture!');
                    return;
                }
                
                const action = {
                    type: 'capture',
                    handCard: selectedHandCard,
                    boardCards: selectedBoardCards,
                    score: [selectedHandCard, ...selectedBoardCards].reduce((sum, card) => sum + card.score, 0)
                };
                
                setSelectedHandCard(null);
                setSelectedBoardCards([]);
                executeAction(action);
            };

            const placeCard = () => {
                if (!selectedHandCard || isAIThinking) return;
                
                const action = {
                    type: 'place',
                    handCard: selectedHandCard
                };
                
                setSelectedHandCard(null);
                executeAction(action);
            };

            const Card = ({ card, onClick, selected, size = 'normal' }) => {
                const isRed = ['‚ô•', '‚ô¶'].includes(card.suit);
                const sizes = { small: 'w-10 h-14 text-xs', normal: 'w-12 h-16 text-sm', large: 'w-14 h-20 text-base' };
                
                return React.createElement('div', {
                    onClick: onClick,
                    className: `${sizes[size]} ${isRed ? 'text-red-600' : 'text-black'} ${selected ? 'bg-blue-200 border-blue-500' : 'bg-white border-gray-300'} border-2 rounded-lg flex flex-col items-center justify-between p-1 font-bold shadow-sm cursor-pointer hover:shadow-md transition-all`
                }, [
                    React.createElement('div', { key: 'rank', className: 'text-xs' }, card.rank),
                    React.createElement('div', { key: 'suit', className: 'text-lg' }, card.suit),
                    React.createElement('div', { key: 'score', className: 'text-xs' }, card.score)
                ]);
            };

            return React.createElement('div', {
                className: 'min-h-screen bg-gradient-to-br from-green-600 to-green-800 text-white p-4'
            }, [
                React.createElement('div', { key: 'container', className: 'max-w-4xl mx-auto' }, [
                    React.createElement('h1', { key: 'title', className: 'text-4xl font-bold text-center mb-6' }, 'STACKED!'),
                    
                    !gameStarted ? 
                        React.createElement('div', { key: 'start', className: 'text-center' },
                            React.createElement('button', {
                                onClick: startGame,
                                className: 'bg-yellow-500 hover:bg-yellow-400 text-black px-8 py-3 rounded-lg font-bold text-lg'
                            }, 'Start Game')
                        ) :
                        React.createElement('div', { key: 'game', className: 'space-y-6' }, [
                            React.createElement('div', { key: 'message', className: 'bg-white/10 backdrop-blur rounded-lg p-4 text-center' },
                                React.createElement('p', { className: 'font-semibold' }, message)
                            ),
                            
                            React.createElement('div', { key: 'deck-info', className: 'bg-white/10 backdrop-blur rounded-lg p-3 text-center' },
                                React.createElement('p', { className: 'font-bold' }, `Deck: ${deck.length} cards remaining`)
                            ),
                            
                            React.createElement('div', { key: 'scores', className: 'grid grid-cols-3 gap-4' },
                                players.map(player =>
                                    React.createElement('div', {
                                        key: player.id,
                                        className: `bg-white/10 backdrop-blur rounded-lg p-3 text-center ${currentPlayer === player.id ? 'ring-2 ring-yellow-400' : ''}`
                                    }, [
                                        React.createElement('div', { key: 'name', className: 'font-bold' }, player.name),
                                        React.createElement('div', { key: 'score', className: 'text-2xl font-bold text-yellow-300' }, player.score),
                                        React.createElement('div', { key: 'cards', className: 'text-sm opacity-75' }, `${player.hand.length} cards`)
                                    ])
                                )
                            ),
                            
                            React.createElement('div', { key: 'board', className: 'bg-white/10 backdrop-blur rounded-lg p-4' }, [
                                React.createElement('h3', { key: 'board-title', className: 'font-bold mb-3' }, 'Board Cards'),
                                React.createElement('div', { key: 'board-cards', className: 'flex flex-wrap gap-2 min-h-20' },
                                    boardCards.map(card =>
                                        React.createElement(Card, {
                                            key: card.id,
                                            card: card,
                                            onClick: () => selectBoardCard(card),
                                            selected: selectedBoardCards.some(c => c.id === card.id)
                                        })
                                    )
                                )
                            ]),
                            
                            React.createElement('div', { key: 'hand', className: 'bg-white/10 backdrop-blur rounded-lg p-4' }, [
                                React.createElement('h3', { key: 'hand-title', className: 'font-bold mb-3' }, 'Your Hand'),
                                React.createElement('div', { key: 'hand-cards', className: 'flex flex-wrap gap-2 justify-center' },
                                    players[0]?.hand.map(card =>
                                        React.createElement(Card, {
                                            key: card.id,
                                            card: card,
                                            onClick: () => selectHandCard(card),
                                            selected: selectedHandCard?.id === card.id,
                                            size: 'large'
                                        })
                                    ) || []
                                )
                            ]),
                            
                            selectedHandCard && currentPlayer === 0 && !isAIThinking && gameState === 'PLAYING' ?
                                React.createElement('div', { key: 'actions', className: 'flex gap-4 justify-center' }, [
                                    React.createElement('button', {
                                        key: 'capture',
                                        onClick: captureCards,
                                        disabled: selectedBoardCards.length === 0 || !canCapture(selectedHandCard, selectedBoardCards),
                                        className: 'bg-blue-600 hover:bg-blue-500 disabled:bg-gray-600 disabled:opacity-50 px-6 py-3 rounded-lg font-bold'
                                    }, `Capture (${selectedBoardCards.length})`),
                                    React.createElement('button', {
                                        key: 'place',
                                        onClick: placeCard,
                                        className: 'bg-orange-600 hover:bg-orange-500 px-6 py-3 rounded-lg font-bold'
                                    }, 'Place Card')
                                ]) : null
                        ])
                ])
            ]);
        };

        ReactDOM.render(React.createElement(StackedGame), document.getElementById('root'));
    </script>
</body>
</html>